a <- 10
b <- 35
c <- a + b
a <- c(3, 5, 2)
b <- c(2, 7, 7)
c <- a + b
d <- c(1, 4, 2, 3)
e <- c(5, 6, 4, 3)
f <- d * e
g <- d + f

j <- c(2, 3, 5, 4, 3, 2, 3, 6, 7)
k <- c(1, 4, 5, 2, 6, 7, 8, 9, 8)
m <- cbind(j, k)
m[,1]
m[,2]

m <- cbind(m,m[,1] + m[,2])
c1 <- '0'
c2 <- '5'
# c1+c2 # Error in c1 + c2 : non-numeric argument to binary operator
# c1 and c2 are not numbers but strings if written inside the single quatation marks.

a <- c(2, 5, 3, 2, 1)
b <- a[1:2]
c <- a[2:3]

a <- c(100, 300, 200, 500, 200)
b <- log(a[1] + a[4]) # If adding the base: b <- log(a[1] + a[4], base = 10)
a <- runif(100, 0, 1) # Half open interval so you never get 0 and 1
hist(a)
summary(a)
# Since runif means creating random numbers so every time you do it it will produce different result.
# A possible solution is control the runif() function by introducing set.seed().
# If we put in the same numbrs in set.seed(), runif() would produce the same series of numbers.

set.seed(100)
m <- matrix(runif(1000), ncol = 10, nrow = 100) # the dufault value for runif is from 0 to 1
m
v <- c(3, 9, 1, 8, 0) 
order(v) # "5 3 1 4 2" means the order ranked from lowest to highest
m_ordered <- m[order(m[,1]),] # [,1] means column 1
m_ordered <- m[order(-m[,1]),] # descending order
m_ordered <- m[floor(runif(100)*100)+1,]
m_ordered
# "floor(run(100)*100)+1" means a random integar between 1 and 100. 
# So the code means extract a random row from m 100 times and form a new matrix.

sub1 <- m[m[,1] < 0.5]
sub2 <- m[m[,1] >= 0.5]

m <- ifelse(m > 0.3, 0, 1) # 用这个ifelse来做判断
m

m[m[,1] > 0.5, 1] <- 1
m[m[,1] <=0.5, 1] <- 0
m

# 如果这后面改成2，意思是用第一column的数来判断，但assign的值对应第二column
m[m[,1] > 0.5, 2] <- 1
m[m[,1] <=0.5, 2] <- 0
m

# 如果这后面改成1:10，意思是用第一column的数来判断，但assign所有column的值
m[m[,1] > 0.5, 1:10] <- 1
m[m[,1] <=0.5, 1:10] <- 0
m

# install.packages("curl")
library(curl)

# Import data from a website
data_csv <- read.csv(curl("http://www.healthgeomatics.com/wp-content/uploads/2016/05/Canadian-populated-places.csv"))
is.data.frame(data_csv) # verify if it's data frame (行-obersvations, 列-variables)
data_csv$name <- as.factor(data_csv$name) # 把字符串变成factor（指分类的指标，有层级(levels))
unique_names <- levels(data_csv$name)  # 其实这里的$name不是factor variable(fct)而是chr
# unique_names2 <- unique(data_csv$name) # 把level改成unique就能对chr做处理
length(unique_names)
number_unique <- length(unique_names)

data_csv$named <- as.character(data_csv$name)
Alvany <- data_csv[data_csv$name=="Albany",]

# put the names of places in a new data object
place_names <- data_csv$name

# count the length of place names
place_names_len <- nchar(as.character(place_names))
# create new data frames
places <- data.frame(place_names, place_names_len)

# sort the data frame in descending order
places <- places[order(-places$place_names_len),] # 可以类比matrix的m[order(m[,1]),]
# sort the data frame in ascending order
places <- places[order(places$place_names_len),] 

install.packages("data_table")
places$cnt <- 1
aplaces <- aggregate(places$cnt, by = list(places$place_names), FUN = sum)
names(aplaces) <- c("Var1","Freq") # rename the variables in the data so they are consistent with the ones generated by the table() function above to change variable names
aplaces <- aplaces[order(-aplaces$Freq),]
most_common <- aplaces[1, ]

# random normal data
rand1 <- rnorm(100, 0, 1)  # normal distribution  # 这种自动create100行1列的vector
rand2 <- rnorm(100, 0, 1)

the_data <- data.frame(cbind(rand1, rand2))

# reclassify variable
the_data$r1class[the_data$rand1 > 0] <- "Positive"
the_data$r1class[the_data$rand1 < 0] <- "Negative"

dataagg <- aggregate(the_data$rand2, by = list(the_data$r1class), FUN = mean) # "by = list" specifies that the data should be grouped by r1class / "Fun" means function
names(dataagg) <- c("class", "average_r2")

m <- matrix(ceiling(runif(9) * 10), nrow = 3) # integar between 1-10
result1 <- apply(m, 1, sum) # 1 indicates row
result2 <- apply(m, 2, sum) # 2 indicates column
difference_max_min1 <- function(x){return(max(x) - min(x))}
result3 <- apply(m, 2, difference_max_min1)

difference_max_min2 <- function(x){return(mean(x) - min(x))}
result4 <- apply(m, 1, difference_max_min2)


data_csv2 <- read.csv(curl("http://www.healthgeomatics.com/wp-content/uploads/2016/06/HockeySeasonData.csv"))
the_data <- data.frame(if("Year" >= 2005))

calculate_total_points <- sum(x)
totalpoints = apply(m, )






