---
title: "Assignment9"
author: "Haoran Xu"
date: "2024-11-18"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
#initialise
n <- 20
grid <- matrix(sample(c(0,1),n^2,replace=TRUE),nrow=n)
timeSteps <- 10

#function to calculate the next state
nextState <- function(grid) {
  n <- nrow(grid)
  newGrid <- matrix(0,nrow=n,ncol=n)
  for (i in 1:n) {
    for (j in 1:n) {
      #this line of code calculates the number of living neighbours for a
      #given cell(i,j) in the grid, considering the boundaries of the grid,
      #and stores the result in the variable aliveNeighbors.
      aliveNeighbors <- sum(grid[max(i-1,1):min(i+1,n),
                                 max(j-1,1):min(j+1,n)])-grid[i,j]
      if (grid[i,j]==1 && (aliveNeighbors<2 || aliveNeighbors>3)) {
        newGrid[i,j] <- 0
      } else if (grid[i,j]==1 || aliveNeighbors==3) {
        newGrid[i,j] <- 1
      }
    }
  }
  return(newGrid)
}

#run it
for (t in 1:timeSteps) {
  grid <- nextState(grid)
  image(1:n,1:n,z=grid,col= c("white","black"),axes=FALSE,xlab="",ylab="")
  title(paste("Time step:", t))
  Sys.sleep(1) #pause for a second to see the evolution
}

```


## Q1.  Looking at the visual output ABM, briefly describe what appears to be happening on the output image.  Does the pattern appear ‘random’, or is there something else going on?


```{r}
gridSize <- 10
numAgents <- 15
timeSteps <- 10

#initialize agents
colours <- c("red","blue","pink","black","grey","green","cyan","yellow")
style <- c(19,20,21,22)
agents <- data.frame(x = sample(1:gridSize,numAgents,replace = TRUE),
                     y = sample(1:gridSize,numAgents,replace = TRUE),
                     c = sample(colours,numAgents,replace=TRUE),
                     p = sample(style,numAgents,replace=TRUE))

#agent behaviour
updateAgents <- function(agents) {
  for (i in 1:nrow(agents)) {
    move <- sample(c("up","down","left","right"),1)
    if (move == "up" && agents$y[i] < gridSize) agents$y[i] <- agents$y[i] + 1
    if (move == "down" && agents$y[i] > 1) agents$y[i] <- agents$y[i] - 1
    if (move == "left" && agents$x[i] > 1) agents$x[i] <- agents$x[i] - 1
    if (move == "right" && agents$x[i] < gridSize) agents$x[i] <- agents$x[i] + 1
  }
  return(agents)
}

#simulation
for (t in 1:timeSteps) {
  plot(agents$x,agents$y,xlim=c(1, gridSize),
       ylim=c(1,gridSize),
       pch=agents$p,col=agents$c,xlab="X",ylab="Y")
  title(paste("Time Step:", t))
  Sys.sleep(0.5)#pause to visualise...
  agents <- updateAgents(agents)
}

```


## Q2.  Looking at the code, describe what is happening in this ABM.  Try to describe the behaviour of the agents with reference to the code.



## Q3. Read through and experiment with the code.  What are the key functions that define agent behaviour, and how do they work?

```{r}
install.packages("simecol")
library(simecol)

#predator-prey model
predator_prey <- new("odeModel",
                     main = function(time, init, parms) {
                       with(as.list(c(init, parms)), {
                         dPrey=r*Prey-a*Predators*Prey
                         dPred=-s*Predators+e*a*Predators*Prey
                         list(c(dPrey,dPred))
                       })
                     },
                     parms = c(r=0.5,a=0.02,s=0.5,e=0.1),
                     #r - prey birth rate
                     #a - predation rate
                     #s - death rate of predators
                     #e - efficiency of converting food (prey) into predator births
                     times = c(from=0,to=200,by=1),
                     init = c(Prey=40,Predators=9), #starting populations
                     solver = "lsoda"
)

predator_prey <- sim(predator_prey)
plot(predator_prey)

```


## Q4. Find a way to plot all the results on a single plot instead of on two separate plots.  Write out your code.


```{r}
#innovation diffusion model
#A is the proportion of population that has adopted the innovation
#R: The rate at which individuals adopt innovation
#B: The rate at which individuals abandon innovation
#I: The rate at which adopters influence non-adopters to adopt innovation
inn_diff <- new("odeModel",
                            main = function(time, init, parms) {
                              with(as.list(c(init, parms)), {
                                dA=R*(1-A)-B*A+I*A*(1-A)
                                list(c(dA))
                              })
                            },
                            parms = c(R=0.1,B=0.02,I=0.05),
                            times = c(from=0,to=100,by=1),
                            init = c(A=0.01),
                            solver = "lsoda"
)

#simulate
inn_diff <- sim(inn_diff)
plot(inn_diff,main="Innovation diffusion")
```



## Q5. Come up with a new parameter to add to the equation predicting the rate of diffusion.  Don’t worry about mathematical rigour; just modify the code to add a new term and ensure that the code runs without warnings/errors.  Explain the change you’ve made, and how it alters the behaviour of the model.

```{r}
#define the SIR model
SIR_model <- new("odeModel",
                 main = function(time,init,parms) {
                   with(as.list(c(init,parms)), {
                     dS = -b * S * I
                     dI = b * S * I - g * I
                     dR = g * I
                     list(c(dS, dI, dR))
                   })
                 },
                 parms = c(b = 0.3, g = 0.1),
                 times = c(from = 0, to = 100, by = 1),
                 init = c(S = 0.99, I = 0.01, R = 0),
                 solver = "lsoda"
)

SIR_model <- sim(SIR_model)
plot(SIR_model)
```


## Q6. Modify the code to account for the fact that immunity to infection is not permanent.


